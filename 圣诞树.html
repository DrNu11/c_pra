<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>æ‰‹åŠ¿æ§åˆ¶ 3D åœ£è¯æ ‘ Â· Three.js + MediaPipe Hands</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at 20% 0%,
                    #f8e7c6 0%, #1b2622 40%, #050608 100%);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #f9f5e5;
        }

        body {
            display: flex;
            align-items: stretch;
            justify-content: stretch;
        }

        /* ä¸»å®¹å™¨ï¼šå·¦ä¾§ Three.js ç”»é¢ï¼Œå³ä¸Šè§’æ§åˆ¶ä¿¡æ¯ */
        #app {
            position: relative;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        /* Three.js æ¸²æŸ“ç”»å¸ƒå®¹å™¨ï¼ŒåŠ ä¸Šâ€œç”µå½±æ„Ÿâ€å¤–å‘å…‰ */
        #three-container {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 28px;
            overflow: hidden;
            backdrop-filter: blur(20px) saturate(130%);
            background: radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.12), rgba(0, 0, 0, 0.8));
            box-shadow:
                0 0 80px rgba(255, 215, 120, 0.45),
                0 0 160px rgba(198, 0, 60, 0.30),
                0 40px 120px rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        canvas#three-canvas {
            width: 100%;
            height: 100%;
            display: block;
            filter: saturate(115%) contrast(110%);
        }

        /* UI é¡¶æ  */
        #hud {
            position: absolute;
            top: 18px;
            left: 22px;
            right: 22px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
        }

        #title-block {
            pointer-events: auto;
        }

        #title-block h1 {
            font-size: 22px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #ffe6a8;
        }

        #title-block h1 span {
            color: #ff4358;
        }

        #title-block p {
            font-size: 12px;
            opacity: 0.82;
            margin-top: 4px;
        }

        #control-panel {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            pointer-events: auto;
        }

        #control-panel .badge {
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 999px;
            background: linear-gradient(120deg, rgba(255, 215, 120, 0.24), rgba(255, 88, 120, 0.4));
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 14px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
        }

        #control-panel label {
            font-size: 11px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.45);
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        #control-panel input[type=file] {
            font-size: 11px;
        }

        #state-indicator {
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 999px;
            background: linear-gradient(120deg, rgba(0, 0, 0, 0.7), rgba(26, 82, 63, 0.9));
            border: 1px solid rgba(173, 255, 204, 0.3);
            box-shadow: 0 0 16px rgba(0, 0, 0, 0.7);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        #state-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6cffb1;
            box-shadow: 0 0 10px rgba(108, 255, 177, 0.9);
        }

        /* æ‰‹åŠ¿æç¤ºæµ®å±‚ */
        #gesture-help {
            position: absolute;
            left: 22px;
            bottom: 22px;
            padding: 10px 12px;
            border-radius: 18px;
            background: radial-gradient(circle at 0 0, rgba(255, 255, 255, 0.16), rgba(0, 0, 0, 0.85));
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(14px);
            font-size: 11px;
            line-height: 1.7;
            pointer-events: none;
            max-width: 340px;
        }

        #gesture-help strong {
            color: #ffe8a7;
        }

        #gesture-help span.g {
            color: #ff6677;
            font-weight: 600;
        }

        /* æ‘„åƒå¤´é¢„è§ˆï¼ˆå³ä¸‹è§’å°çª—å£ï¼‰ */
        #camera-preview-wrapper {
            position: absolute;
            right: 22px;
            bottom: 22px;
            width: 220px;
            height: 160px;
            border-radius: 18px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 0 22px rgba(0, 0, 0, 0.85);
            background: radial-gradient(circle at 0 0, rgba(255, 255, 255, 0.2), rgba(5, 5, 5, 0.9));
            display: flex;
            flex-direction: column;
            pointer-events: none;
            backdrop-filter: blur(16px);
        }

        #camera-preview-title {
            font-size: 11px;
            padding: 4px 8px;
            color: #ffe8b0;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.8);
        }

        #camera-preview {
            position: relative;
            flex: 1;
            overflow: hidden;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* é•œåƒï¼Œç¬¦åˆç”¨æˆ·ç›´è§‰ */
        }

        #hand-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }

        /* å°å±é€‚é… */
        @media (max-width: 768px) {
            #three-container {
                border-radius: 0;
            }

            #gesture-help {
                font-size: 10px;
                max-width: 260px;
            }

            #camera-preview-wrapper {
                width: 180px;
                height: 130px;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="three-container">
            <canvas id="three-canvas"></canvas>

            <div id="hud">
                <div id="title-block">
                    <h1><span>Hand</span> Crafted Christmas Tree</h1>
                    <p>ç”¨ä½ çš„æ‰‹åŠ¿ï¼Œå”¤é†’ä¸€æ£µç”±ç²’å­ä¸è®°å¿†æ„æˆçš„ 3D åœ£è¯æ ‘ã€‚</p>
                </div>
                <div id="control-panel">
                    <div class="badge">Three.js Â· WebGL Â· MediaPipe Hands</div>
                    <label>
                        <span>ä¸Šä¼ ç…§ç‰‡ï¼ˆæ„æˆç…§ç‰‡äº‘ï¼‰</span>
                        <input id="photo-input" type="file" accept="image/*" multiple />
                    </label>
                    <div id="state-indicator">
                        <div id="state-dot"></div>
                        <span id="state-label">åˆæ‹¢æ€ Â· åœ£è¯æ ‘</span>
                    </div>
                </div>
            </div>

            <div id="gesture-help">
                <strong>æ‰‹åŠ¿è¯´æ˜</strong><br>
                <span class="g">âœŠ æ¡æ‹³</span>ï¼šå›åˆ° <strong>åˆæ‹¢æ€</strong>ï¼ˆåœ£è¯æ ‘æ”¶æ‹¢æˆç»å…¸è½®å»“ï¼‰<br>
                <span class="g">ğŸ– å¼ å¼€äº”æŒ‡</span>ï¼šè¿›å…¥ <strong>æ•£å¼€æ€</strong>ï¼ˆç²’å­ &amp; ç¤¼ç‰©åœ¨ç©ºé—´ä¸­æ¼‚æµ®ï¼‰<br>
                <span class="g">ğŸ¤ æŠ“/æ</span>ï¼šä»æ•£å¼€æ€ä¸­ <strong>æŠ“ä½ä¸€å¼ ç…§ç‰‡</strong> å¹¶æ”¾å¤§ï¼ˆç…§ç‰‡æ”¾å¤§æ€ï¼‰<br>
                <span class="g">ğŸ¤² æ‰‹æ—‹è½¬ / ç§»åŠ¨</span>ï¼šåœ¨æ•£å¼€æ€ä¸‹ï¼Œ<strong>æ—‹è½¬ &amp; ç¯è§†</strong> æ•´æ£µåœ£è¯æ ‘
            </div>

            <div id="camera-preview-wrapper">
                <div id="camera-preview-title">MediaPipe Hands Â· æ‰‹åŠ¿è¯†åˆ«é¢„è§ˆ</div>
                <div id="camera-preview">
                    <video id="input-video" playsinline></video>
                    <canvas id="hand-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>

    <!-- MediaPipe Hands & camera utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        // -------------------------------
        // åœºæ™¯ & æ¸²æŸ“åˆå§‹åŒ–
        // -------------------------------
        const canvas = document.getElementById('three-canvas');
        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth - 32, window.innerHeight - 32);
        renderer.outputEncoding = THREE.sRGBEncoding;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050608, 0.035);

        const camera = new THREE.PerspectiveCamera(
            45,
            (window.innerWidth - 32) / (window.innerHeight - 32),
            0.1,
            200
        );
        camera.position.set(0, 3.8, 11);
        scene.add(camera);

        // ç¯å¢ƒå…‰ + æŸ”å’Œç‚¹å…‰æºï¼Œé‡‘å±é‡‘è‰²è°ƒ
        const ambientLight = new THREE.AmbientLight(0xf8f2e7, 0.6);
        scene.add(ambientLight);

        const warmKeyLight = new THREE.PointLight(0xffe4b5, 1.5, 40);
        warmKeyLight.position.set(6, 10, 8);
        scene.add(warmKeyLight);

        const redRimLight = new THREE.PointLight(0xff3355, 1.2, 40);
        redRimLight.position.set(-8, 5, -6);
        scene.add(redRimLight);

        const greenFillLight = new THREE.PointLight(0x3bdc7b, 0.8, 40);
        greenFillLight.position.set(0, 9, 0);
        scene.add(greenFillLight);

        // è½»å¾®ç¯å¢ƒä½“ç§¯æ„Ÿ
        const floorGeo = new THREE.CircleGeometry(16, 64);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x1b2622,
            metalness: 0.6,
            roughness: 0.85,
            emissive: 0x00150a,
            emissiveIntensity: 0.4
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -4;
        scene.add(floor);

        // -------------------------------
        // ç²’å­åœ£è¯æ ‘ï¼ˆInstancedMeshï¼‰
        // -------------------------------
        const GROUP_STATE = {
            TREE: 'TREE',
            SCATTER: 'SCATTER',
            PHOTO_FOCUS: 'PHOTO_FOCUS'
        };
        let currentState = GROUP_STATE.TREE;
        let targetState = GROUP_STATE.TREE;
        let stateBlend = 0;       // 0=å®Œå…¨TREE, 1=å®Œå…¨SCATTER
        let focusBlend = 0;       // 0=éç…§ç‰‡æ”¾å¤§ï¼Œ1=å®Œå…¨ç…§ç‰‡æ”¾å¤§
        let focusedPhoto = null;  // å½“å‰æ”¾å¤§çš„ç…§ç‰‡ Mesh

        const ornamentGroup = new THREE.Group();
        scene.add(ornamentGroup);

        const coneHeight = 6.0;
        const coneRadius = 2.6;
        const ornamentCount = 320;

        const ornamentBasePositions = [];
        const ornamentScatterPositions = [];
        const ornamentTypes = [];

        // ä¸‰ç§æè´¨ï¼šå“‘å…‰ç»¿ä¸»ä½“ + é‡‘å±é‡‘ + åœ£è¯çº¢
        const baseGreenMat = new THREE.MeshStandardMaterial({
            color: 0x264f35,
            roughness: 0.9,
            metalness: 0.25,
            emissive: 0x0a1e14,
            emissiveIntensity: 0.6
        });
        const goldMat = new THREE.MeshStandardMaterial({
            color: 0xfad873,
            roughness: 0.3,
            metalness: 1.0,
            emissive: 0x8b5a16,
            emissiveIntensity: 0.7
        });
        const redMat = new THREE.MeshStandardMaterial({
            color: 0xff3355,
            roughness: 0.5,
            metalness: 0.7,
            emissive: 0x3a0208,
            emissiveIntensity: 0.7
        });

        const sphereGeo = new THREE.SphereGeometry(0.12, 12, 12);
        const boxGeo = new THREE.BoxGeometry(0.16, 0.16, 0.16);

        const instancedCount = ornamentCount;
        const ornamentMesh = new THREE.InstancedMesh(sphereGeo, baseGreenMat, instancedCount);
        const ornamentMesh2 = new THREE.InstancedMesh(boxGeo, goldMat, instancedCount);
        ornamentMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        ornamentMesh2.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        ornamentGroup.add(ornamentMesh);
        ornamentGroup.add(ornamentMesh2);

        const dummy = new THREE.Object3D();

        function randomConePosition() {
            const h = Math.random() * coneHeight;
            const radiusAtH = (coneRadius * (coneHeight - h)) / coneHeight + 0.2;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radiusAtH;
            const z = Math.sin(angle) * radiusAtH;
            const y = h - coneHeight / 2;
            return new THREE.Vector3(x, y + 0.4, z);
        }

        function randomScatterPosition() {
            const r = 6 + Math.random() * 6;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.cos(phi) - 1;
            const z = r * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        for (let i = 0; i < ornamentCount; i++) {
            const basePos = randomConePosition();
            const scatterPos = randomScatterPosition();
            ornamentBasePositions.push(basePos);
            ornamentScatterPositions.push(scatterPos);
            ornamentTypes.push(Math.random() < 0.5 ? 0 : 1); // 0 çƒï¼Œ1 ç›’
        }

        function updateOrnamentsMatrices() {
            for (let i = 0; i < ornamentCount; i++) {
                const basePos = ornamentBasePositions[i];
                const scatterPos = ornamentScatterPositions[i];

                const pos = basePos.clone().lerp(scatterPos, stateBlend);
                const scaleFactor = THREE.MathUtils.lerp(1.0, 1.4, stateBlend);
                const swirl = stateBlend * 2.0;
                const angleOffset = swirl * (pos.y * 0.3 + i * 0.03);
                const finalX = pos.x * Math.cos(angleOffset) - pos.z * Math.sin(angleOffset);
                const finalZ = pos.x * Math.sin(angleOffset) + pos.z * Math.cos(angleOffset);
                const yFloat = pos.y + Math.sin(performance.now() * 0.0008 + i * 0.2) * stateBlend * 0.4;

                dummy.position.set(finalX, yFloat, finalZ);
                const s = scaleFactor * (0.6 + Math.random() * 0.6);
                dummy.scale.set(s, s, s);
                dummy.lookAt(0, pos.y, 0);
                dummy.updateMatrix();

                if (ornamentTypes[i] === 0) {
                    ornamentMesh.setMatrixAt(i, dummy.matrix);
                } else {
                    ornamentMesh2.setMatrixAt(i, dummy.matrix);
                }
            }
            ornamentMesh.instanceMatrix.needsUpdate = true;
            ornamentMesh2.instanceMatrix.needsUpdate = true;
        }

        updateOrnamentsMatrices();

        // æ˜Ÿæ˜Ÿé¡¶é¥°
        const starGeo = new THREE.SphereGeometry(0.48, 12, 12);
        const starMat = new THREE.MeshStandardMaterial({
            color: 0xfff2a0,
            metalness: 1.0,
            roughness: 0.15,
            emissive: 0xffe17a,
            emissiveIntensity: 1.7
        });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.set(0, coneHeight / 2 + 0.6, 0);
        scene.add(star);

        // ç³–æœæ£ï¼ˆç®€å•çš„çº¢ç™½æ¡ cylinder + tubeï¼‰
        const candyGroup = new THREE.Group();
        const candyMaterialWhite = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.4,
            roughness: 0.5,
            emissive: 0x201f22,
            emissiveIntensity: 0.4
        });
        const candyMaterialRed = new THREE.MeshStandardMaterial({
            color: 0xff3355,
            metalness: 0.4,
            roughness: 0.6,
            emissive: 0x2b0205,
            emissiveIntensity: 0.5
        });

        const candyCount = 14;
        for (let i = 0; i < candyCount; i++) {
            const h = coneHeight * (0.2 + Math.random() * 0.7);
            const radiusAtH = (coneRadius * (coneHeight - h)) / coneHeight + 0.3;
            const angle = (i / candyCount) * Math.PI * 2 + Math.random() * 0.2;
            const x = Math.cos(angle) * radiusAtH;
            const z = Math.sin(angle) * radiusAtH;
            const y = h - coneHeight / 2 + 0.2;

            const bodyGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 12);
            const body = new THREE.Mesh(bodyGeo, candyMaterialWhite);
            body.position.set(x, y, z);
            body.lookAt(0, y, 0);
            body.rotateX(-Math.PI / 4);

            const hookCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0.6, 0),
                new THREE.Vector3(0.3, 0.8, 0.2),
                new THREE.Vector3(0.2, 1.0, 0.4)
            );
            const hookGeo = new THREE.TubeGeometry(hookCurve, 20, 0.08, 8, false);
            const hook = new THREE.Mesh(hookGeo, candyMaterialRed);
            hook.position.copy(body.position);
            hook.quaternion.copy(body.quaternion);

            candyGroup.add(body);
            candyGroup.add(hook);
        }
        scene.add(candyGroup);

        // æ•£æ™¯èƒŒæ™¯å°ç²’å­
        const bokehGeo = new THREE.SphereGeometry(0.07, 8, 8);
        const bokehMat = new THREE.MeshBasicMaterial({
            color: 0xfff0cc,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        const bokehCount = 180;
        const bokehMesh = new THREE.InstancedMesh(bokehGeo, bokehMat, bokehCount);
        const bokehPositions = [];
        for (let i = 0; i < bokehCount; i++) {
            const r = 10 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.cos(phi);
            const z = r * Math.sin(phi) * Math.sin(theta);
            bokehPositions.push(new THREE.Vector3(x, y, z));
            dummy.position.set(x, y, z);
            const s = 0.4 + Math.random() * 1